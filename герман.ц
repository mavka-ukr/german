зовнішня дія malloc(розмір: size_t): адреса;
зовнішня дія realloc(памʼять: адреса, розмір: size_t): адреса;
зовнішня дія free(памʼять: адреса);
зовнішня дія putchar(символ: char): int;
зовнішня дія printf(формат: адреса): int;

дія виділити<Т>(): адреса<Т>;
дія виділити<Т>(кількість: позитивне): памʼять<Т>;
дія перевиділити<Т>(значення: памʼять<Т>, кількість: позитивне): памʼять<Т>;
дія звільнити(значення: адреса);

дія виділити<Т>(): адреса<Т> {
  вернути malloc(size_t(Т.розмір)) як адреса<Т>;
}

дія виділити<Т>(кількість: позитивне): памʼять<Т> {
  вернути malloc(size_t(кількість) * Т.розмір) як памʼять<Т>;
}

дія перевиділити<Т>(значення: памʼять<Т>, кількість: позитивне): памʼять<Т> {
  вернути realloc(значення як адреса, size_t(кількість) * Т.розмір) як памʼять<Т>;
}

дія звільнити(значення: адреса) {
  free(значення);
}

дія вивести_Ю8(значення: памʼять<п8>) {
  printf(значення як адреса);
}

дія надрукувати_Ю8(значення: памʼять<п8>) {
  вивести_Ю8(значення);
  вивести_Ю8(ю8"\n");
}

зовнішня дія print_long(value: long);
зовнішня дія println_long(value: long);
зовнішня дія read_file(path: адреса<char>, out_address: адреса<адреса<char>>): size_t;

дія ЯТУТ() {
  надрукувати_Ю8(ю8"ЯТУТ");
}

дія порахувати_розмір_Ю8(значення: памʼять<п8>): позитивне {
  змінна ціль розмір: позитивне = 0;
  поки значення[розмір] != 0 {
    розмір += 1;
  }
  вернути розмір;
}

дія порахувати_розмір_Ю32(значення: памʼять<п32>): позитивне {
  змінна ціль розмір: позитивне = 0;
  поки значення[розмір] != 0 {
    розмір += 1;
  }
  вернути розмір;
}

дія дізнатись_розмір_символа_юнікоду(перший_байт: п8): п8 {
  якщо (перший_байт & 128) == 0 {
    вернути 1;
  }
  якщо (перший_байт & 224) == 192 {
    вернути 2;
  }
  якщо (перший_байт & 240) == 224 {
    вернути 3;
  }
  якщо (перший_байт & 248) == 240 {
    вернути 4;
  }
  вернути 0;
}

дія перекодувати_Ю8_в_Ю32(вхід: памʼять<п8>, розмір_входу: позитивне, адреса_виходу: адреса<памʼять<п32>>): позитивне {
  змінна ціль вихід: памʼять<п32> = виділити<п32>(розмір_входу + 1);
  змінна ціль розмір_виходу: позитивне = 0;
  змінна ціль х: позитивне = 0;
  поки х < розмір_входу {
    ціль перший_байт = вхід[х];
    ціль розмір_символа = дізнатись_розмір_символа_юнікоду(перший_байт);
    якщо розмір_символа == 1 {
      вихід[розмір_виходу] = п32(перший_байт & 127);
      розмір_виходу = розмір_виходу + 1;
    }
    якщо розмір_символа == 2 {
      ціль другий_байт = вхід[х + 1];
      вихід[розмір_виходу] = (п32(перший_байт & 31) << 6) | п32(другий_байт & 63);
      розмір_виходу = розмір_виходу + 1;
      х = х + 1;
    }
    якщо розмір_символа == 3 {
      ціль другий_байт = вхід[х + 1];
      ціль третій_байт = вхід[х + 2];
      вихід[розмір_виходу] = (п32(перший_байт & 15) << 12) | (п32(другий_байт & 63) << 6) | п32(третій_байт & 63);
      розмір_виходу = розмір_виходу + 1;
      х = х + 2;
    }
    якщо розмір_символа == 4 {
      ціль другий_байт = вхід[х + 1];
      ціль третій_байт = вхід[х + 2];
      ціль четвертий_байт = вхід[х + 3];
      вихід[розмір_виходу] = (п32(перший_байт & 15) << 18) | (п32(другий_байт & 63) << 12) | (п32(третій_байт & 63) << 6) | п32(четвертий_байт & 63);
      розмір_виходу = розмір_виходу + 1;
      х = х + 3;
    }
    х = х + 1;
  }
  вихід[розмір_виходу] = 0;
  вихід = перевиділити<п32>(вихід, розмір_виходу + 1);
  адреса_виходу::вміст = вихід;
  вернути розмір_виходу;
}

секція UNICODE {
  синонім NEWLINE = 10;
  синонім CARRIAGE_RETURN = 13;
  синонім SPACE = 32;
  синонім APOSTROPHE = 39;
  синонім OPEN_PARENTHESIS = 40;
  синонім CLOSE_PARENTHESIS = 41;
  синонім ASTERISK = 42;
  синонім PLUS = 43;
  синонім COLON = 58;
  синонім SEMICOLON = 59;
  синонім EQUAL = 61;
  синонім QUESTION_MARK = 63;
  синонім OPEN_CURLY_BRACKET = 123;
  синонім LINE = 124;
  синонім CLOSE_CURLY_BRACKET = 125;
}

секція герман {
  секція лексер {
    структура Місцезнаходження {
      рядок_початку: позитивне;
      стовпець_початку: позитивне;
      рядок_кінця: позитивне;
      стовпець_кінця: позитивне;
    }

    структура КлючовеСловоЛексика { пусті_дані: адреса }
    структура КлючовеСловоГраматика { пусті_дані: адреса }
    структура КлючовеСловоФрагмент { пусті_дані: адреса }
    структура ВідкритаДужка { пусті_дані: адреса }
    структура ЗакритаДужка { пусті_дані: адреса }
    структура Зірочка { пусті_дані: адреса }
    структура Плюс { пусті_дані: адреса }
    структура Двокрапка { пусті_дані: адреса }
    структура Крапкакома { пусті_дані: адреса }
    структура Рівно { пусті_дані: адреса }
    структура ЗнакПитання { пусті_дані: адреса }
    структура ВідкритаФігурнаДужка { пусті_дані: адреса }
    структура Пряма { пусті_дані: адреса }
    структура ЗакритаФігурнаДужка { пусті_дані: адреса }
    структура Ідентифікатор { значення: памʼять<п32>; }
    структура Букви { значення: памʼять<п32>; розмір: позитивне; }

    синонім ВидЛексемиКлючовеСловоЛексика = 1;
    синонім ВидЛексемиКлючовеСловоГраматика = 2;
    синонім ВидЛексемиКлючовеСловоФрагмент = 3;
    синонім ВидЛексемиВідкритаДужка = 4;
    синонім ВидЛексемиЗакритаДужка = 5;
    синонім ВидЛексемиЗірочка = 6;
    синонім ВидЛексемиПлюс = 7;
    синонім ВидЛексемиДвокрапка = 8;
    синонім ВидЛексемиКрапкакома = 9;
    синонім ВидЛексемиРівно = 16;
    синонім ВидЛексемиЗнакПитання = 10;
    синонім ВидЛексемиВідкритаФігурнаДужка = 11;
    синонім ВидЛексемиПряма = 12;
    синонім ВидЛексемиЗакритаФігурнаДужка = 13;
    синонім ВидЛексемиІдентифікатор = 14;
    синонім ВидЛексемиБукви = 15; // 16

    структура Лексема {
      вид: позитивне;
      дані: КлючовеСловоЛексика | КлючовеСловоГраматика | КлючовеСловоФрагмент | КлючовеСловоФрагмент | ВідкритаДужка | ЗакритаДужка | Зірочка | Плюс | Двокрапка | Крапкакома | Рівно | ЗнакПитання | ВідкритаФігурнаДужка | Пряма | ЗакритаФігурнаДужка | Ідентифікатор | Букви;
      місцезнаходження: адреса<Місцезнаходження>;
    }

    дія виділити_лексему(дані: Лексема): адреса<Лексема> {
      ціль лексема = виділити<Лексема>();
      лексема.вид = дані.вид;
      лексема.дані = дані.дані як Букви;
      лексема.місцезнаходження = дані.місцезнаходження;
      вернути лексема;
    }

    структура РозібранаЛексика {
      кількість_лексем: позитивне;
      лексеми: памʼять<адреса<Лексема>>;
    }

    дія перевірити_початок_ідентифікатора(значення: памʼять<п32>, позиція_початку: позитивне): логічне {
      ціль символ = значення[позиція_початку];
      якщо символ == UNICODE::NEWLINE {
        вернути ні;
      }
      якщо символ == UNICODE::CARRIAGE_RETURN {
        вернути ні;
      }
      якщо символ == UNICODE::SPACE {
        вернути ні;
      }
      якщо символ == UNICODE::APOSTROPHE {
        вернути ні;
      }
      якщо символ == UNICODE::OPEN_PARENTHESIS {
        вернути ні;
      }
      якщо символ == UNICODE::CLOSE_PARENTHESIS {
        вернути ні;
      }
      якщо символ == UNICODE::ASTERISK {
        вернути ні;
      }
      якщо символ == UNICODE::PLUS {
        вернути ні;
      }
      якщо символ == UNICODE::COLON {
        вернути ні;
      }
      якщо символ == UNICODE::SEMICOLON {
        вернути ні;
      }
      якщо символ == UNICODE::EQUAL {
        вернути ні;
      }
      якщо символ == UNICODE::QUESTION_MARK {
        вернути ні;
      }
      якщо символ == UNICODE::OPEN_CURLY_BRACKET {
        вернути ні;
      }
      якщо символ == UNICODE::LINE {
        вернути ні;
      }
      якщо символ == UNICODE::CLOSE_CURLY_BRACKET {
        вернути ні;
      }
      вернути так;
    }

    дія перевірити_продовження_ідентифікатора(значення: памʼять<п32>, позиція_початку: позитивне): логічне {
      вернути перевірити_початок_ідентифікатора(значення, позиція_початку);
    }

    дія перевірити_ідентифікатор(значення: памʼять<п32>, позиція_початку: позитивне): позитивне {
      якщо перевірити_початок_ідентифікатора(значення, позиція_початку) == ні {
        вернути 0;
      }
      змінна ціль п: позитивне = 1;
      поки значення[позиція_початку + п] != 0 {
        якщо перевірити_продовження_ідентифікатора(значення, позиція_початку + п) == ні {
          вернути п;
        }
        п += 1;
      }
      вернути 0;
    }

    дія перевірити_початок_букв(значення: памʼять<п32>, позиція_початку: позитивне): логічне {
      ціль символ = значення[позиція_початку];
      якщо символ == UNICODE::APOSTROPHE {
        вернути так;
      }
      вернути ні;
    }

    дія перевірити_продовження_букв(значення: памʼять<п32>, позиція_початку: позитивне): логічне {
      ціль символ = значення[позиція_початку];
      якщо символ == UNICODE::APOSTROPHE {
        вернути ні;
      }
      вернути так;
    }

    дія перевірити_закінчення_букв(значення: памʼять<п32>, позиція_початку: позитивне): логічне {
      ціль символ = значення[позиція_початку];
      якщо символ == UNICODE::APOSTROPHE {
        вернути так;
      }
      вернути ні;
    }

    дія перевірити_букви(значення: памʼять<п32>, позиція_початку: позитивне): позитивне {
      якщо перевірити_початок_букв(значення, позиція_початку) == ні {
        вернути 0;
      }
      змінна ціль п: позитивне = 1;
      поки значення[позиція_початку + п] != 0 {
        якщо значення[позиція_початку + п] == 92 {
          п += 1;
        } інакше якщо перевірити_продовження_букв(значення, позиція_початку + п) {
        } інакше якщо перевірити_закінчення_букв(значення, позиція_початку + п) {
          вернути п;
        } інакше {
          вернути 0;
        }
        п += 1;
      }
      вернути 0;
    }

    дія перевірити_ключове_слово(значення: памʼять<п32>, позиція_початку: позитивне, шукане_значення: памʼять<п8>): логічне {
      ціль шукане_значення_Ю32: памʼять<п32> = пусто;
      ціль розмір_шуканого_значення_Ю32 = перекодувати_Ю8_в_Ю32(шукане_значення, порахувати_розмір_Ю8(шукане_значення), шукане_значення_Ю32::адреса);
      змінна ціль п: позитивне = 0;
      поки шукане_значення_Ю32[п] != 0 {
        якщо значення[позиція_початку + п] == 0 {
          звільнити(шукане_значення_Ю32 як адреса);
          вернути ні;
        }
        якщо значення[позиція_початку + п] != шукане_значення_Ю32[п] {
          звільнити(шукане_значення_Ю32 як адреса);
          вернути ні;
        }
        п += 1;
      }
      звільнити(шукане_значення_Ю32 як адреса);
      вернути так;
    }

    структура ПомилкаЛексера {
      рядок: позитивне;
      стовпець: позитивне;
      повідомлення: памʼять<п8>;
    }

    дія розібрати(значення: памʼять<п32>, вихід: адреса<адреса<РозібранаЛексика>>): адреса<ПомилкаЛексера> {
      ціль розібрана_лексика = виділити<РозібранаЛексика>();
      розібрана_лексика.кількість_лексем = 0;
      розібрана_лексика.лексеми = пусто;
      змінна ціль рядок: позитивне = 1;
      змінна ціль стовпець: позитивне = 1;
      змінна ціль п_початку_рядка: позитивне = 0;
      змінна ціль п: позитивне = 0;
      далі:
      стовпець = п - (п_початку_рядка - 1);
      ціль символ = значення[п];
      якщо символ == 0 {
        стрибнути стоп;
      }
      якщо перевірити_ключове_слово(значення, п, ю8"лексика") {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиКлючовеСловоЛексика, КлючовеСловоЛексика { пусто }, місцезнаходження });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 7;
        стрибнути далі;
      }
      якщо перевірити_ключове_слово(значення, п, ю8"граматика") {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиКлючовеСловоГраматика, КлючовеСловоГраматика { пусто }, місцезнаходження });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 9;
        стрибнути далі;
      }
      якщо перевірити_ключове_слово(значення, п, ю8"фрагмент") {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиКлючовеСловоФрагмент, КлючовеСловоФрагмент { пусто }, місцезнаходження });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 8;
        стрибнути далі;
      }
      якщо символ == UNICODE::OPEN_PARENTHESIS {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиВідкритаДужка, ВідкритаДужка { пусто }, місцезнаходження });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::CLOSE_PARENTHESIS {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиЗакритаДужка, ЗакритаДужка { пусто }, місцезнаходження });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::ASTERISK {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиЗірочка, Зірочка { пусто }, місцезнаходження });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::PLUS {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиПлюс, Плюс { пусто }, місцезнаходження });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::COLON {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиДвокрапка, Двокрапка { пусто }, місцезнаходження });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::SEMICOLON {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиКрапкакома, Крапкакома { пусто }, місцезнаходження });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::EQUAL {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиРівно, Рівно { пусто }, місцезнаходження });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::QUESTION_MARK {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиЗнакПитання, ЗнакПитання { пусто }, місцезнаходження });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::OPEN_CURLY_BRACKET {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиВідкритаФігурнаДужка, ВідкритаФігурнаДужка { пусто }, місцезнаходження });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::LINE {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиПряма, Пряма { пусто }, місцезнаходження });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::CLOSE_CURLY_BRACKET {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиЗакритаФігурнаДужка, ЗакритаФігурнаДужка { пусто }, місцезнаходження });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
        стрибнути далі;
      }
      ціль розмір_ідентифікатора = перевірити_ідентифікатор(значення, п);
      якщо розмір_ідентифікатора > 0 {
        ціль значення_ідентифікатора = виділити<п32>(розмір_ідентифікатора + 1);
        змінна ціль пі: позитивне = 0;
        поки пі < розмір_ідентифікатора {
          значення_ідентифікатора[пі] = значення[п + пі];
          пі += 1;
        }
        значення_ідентифікатора[розмір_ідентифікатора] = 0;
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиІдентифікатор, Ідентифікатор { значення_ідентифікатора }, місцезнаходження });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += розмір_ідентифікатора;
        стрибнути далі;
      }
      ціль розмір_букв = перевірити_букви(значення, п);
      якщо розмір_букв > 0 {
        ціль значення_букв = виділити<п32>(розмір_букв);
        змінна ціль пі: позитивне = 0;
        поки пі < (розмір_букв - 1) {
          значення_букв[пі] = значення[п + пі + 1];
          пі += 1;
        }
        значення_букв[розмір_букв - 1] = 0;
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиБукви, Букви { значення_букв, розмір_букв - 1 }, місцезнаходження });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += розмір_букв + 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::NEWLINE {
        п += 1;
        рядок += 1;
        стовпець = 1;
        п_початку_рядка = п;
        стрибнути далі;
      }
      якщо символ == UNICODE::CARRIAGE_RETURN {
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::SPACE {
        п += 1;
        стрибнути далі;
      }
      ціль помилка_лексера = виділити<ПомилкаЛексера>();
      помилка_лексера.рядок = рядок;
      помилка_лексера.стовпець = стовпець;
      помилка_лексера.повідомлення = ю8"Неочікуваний токен";
      вернути помилка_лексера;
      стоп:
      вихід::вміст = розібрана_лексика;
      вернути пусто;
    }
  }

  секція парсер {
    структура АСДЗначення;

    структура Лексика { кількість_елементів: позитивне; елементи: памʼять<адреса<АСДЗначення>>; }
    структура Граматика { кількість_елементів: позитивне; елементи: памʼять<адреса<АСДЗначення>>; }
    структура Фрагмент { ідентифікатор: адреса<лексер::Ідентифікатор>; значення: адреса<АСДЗначення>; }
    структура Визначення { ідентифікатор: адреса<лексер::Ідентифікатор>; значення: адреса<АСДЗначення>; }
    структура Послідовність { кількість_елементів: позитивне; елементи: памʼять<адреса<АСДЗначення>>; }
    структура Або { ліво: адреса<АСДЗначення>; право: адреса<АСДЗначення>; }
    структура ОдинАбоБільше { значення: адреса<АСДЗначення>; }
    структура НульАбоБільше { значення: адреса<АСДЗначення>; }
    структура НульАбоОдин { значення: адреса<АСДЗначення>; }
    структура Буквально { значення: адреса<лексер::Букви>; }

    синонім ВидАСДЗначенняЛексика = 1;
    синонім ВидАСДЗначенняГраматика = 2;
    синонім ВидАСДЗначенняФрагмент = 3;
    синонім ВидАСДЗначенняВизначення = 4;
    синонім ВидАСДЗначенняПослідовність = 5;
    синонім ВидАСДЗначенняАбо = 6;
    синонім ВидАСДЗначенняОдинАбоБільше = 7;
    синонім ВидАСДЗначенняНульАбоБільше = 8;
    синонім ВидАСДЗначенняНульАбоОдин = 9;
    синонім ВидАСДЗначенняБуквально = 10;

    структура АСДЗначення {
      вид: позитивне;
      дані: Лексика | Граматика | Фрагмент | Визначення | Послідовність | Або | ОдинАбоБільше | НульАбоБільше | НульАбоОдин | Буквально;
      місцезнаходження: адреса<лексер::Місцезнаходження>;
    }

    структура ПомилкаПарсера {
      місцезнаходження: адреса<лексер::Місцезнаходження>;
      повідомлення: памʼять<п8>;
    }

    дія спробувати_розібрати_лексику(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера>;
    дія спробувати_розібрати_елемент_лексики(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера>;
    дія спробувати_розібрати_граматику(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера>;
    дія спробувати_розібрати_фрагмент(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера>;
    дія спробувати_розібрати_значення_фрагмента(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера>;
    дія спробувати_розібрати_визначення(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера>;
    дія спробувати_розібрати_послідовність(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера>;
    дія спробувати_розібрати_або(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера>;
    дія спробувати_розібрати_нуль_або_більше(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера>;
    дія спробувати_розібрати_нуль_або_один(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера>;
    дія спробувати_розібрати_буквально(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера>;

    дія спробувати_розібрати_лексику(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера> {
      змінна ціль асд_значення_лексики = виділити<АСДЗначення>();
      асд_значення_лексики.вид = ВидАСДЗначенняЛексика;
      ціль лексика = Лексика { кількість_елементів = 0, елементи = пусто };
      асд_значення_лексики.місцезнаходження = пусто;
      змінна ціль п = позиція_початку;
      якщо розібрана_лексика.лексеми[п].вид != герман::лексер::ВидЛексемиКлючовеСловоЛексика {
        стрибнути помилка;
      }
      п += 1;
      якщо розібрана_лексика.лексеми[п].вид != герман::лексер::ВидЛексемиВідкритаФігурнаДужка {
        стрибнути помилка;
      }
      п += 1;
      поки п < розібрана_лексика.кількість_лексем {
        якщо розібрана_лексика.лексеми[п].вид == герман::лексер::ВидЛексемиЗакритаФігурнаДужка {
          стрибнути стоп;
        }
        змінна ціль асд_значення_елемента_лексики: адреса<АСДЗначення> = пусто;
        змінна ціль закінчення_асд_значення_елемента_лексики: позитивне = 0;
        ціль помилка_розбору_елемента_лексики = спробувати_розібрати_елемент_лексики(розібрана_лексика, п, асд_значення_елемента_лексики::адреса, закінчення_асд_значення_елемента_лексики::адреса);
        якщо помилка_розбору_елемента_лексики != пусто {
          вернути помилка_розбору_елемента_лексики;
        }
        лексика.елементи = перевиділити<адреса<АСДЗначення>>(лексика.елементи, лексика.кількість_елементів + 1);
        лексика.елементи[лексика.кількість_елементів] = асд_значення_елемента_лексики;
        лексика.кількість_елементів += 1;
        п = закінчення_асд_значення_елемента_лексики + 1;
      }
      п = п - 1;
      стоп:
      асд_значення_лексики.дані = лексика;
      адреса_на_асд_значення::вміст = асд_значення_лексики;
      адреса_на_закінчення_асд_значення::вміст = п;
      вернути пусто;
      помилка:
      ціль помилка_парсера = виділити<ПомилкаПарсера>();
      помилка_парсера.місцезнаходження = розібрана_лексика.лексеми[п].місцезнаходження;
      помилка_парсера.повідомлення = ю8"Неочікуваний токен";
      вернути помилка_парсера;
    }

    дія спробувати_розібрати_елемент_лексики(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера> {
      ціль помилка_розбору_фрагмента = спробувати_розібрати_фрагмент(розібрана_лексика, позиція_початку, адреса_на_асд_значення, адреса_на_закінчення_асд_значення);
      якщо помилка_розбору_фрагмента == пусто {
        вернути пусто;
      }
      ціль помилка_розбору_визначення = спробувати_розібрати_визначення(розібрана_лексика, позиція_початку, адреса_на_асд_значення, адреса_на_закінчення_асд_значення);
      якщо помилка_розбору_визначення == пусто {
        вернути пусто;
      }
      вернути помилка_розбору_фрагмента;
    }

    дія спробувати_розібрати_граматику(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера> {
      ціль помилка_парсера = виділити<ПомилкаПарсера>();
      помилка_парсера.місцезнаходження = розібрана_лексика.лексеми[позиція_початку].місцезнаходження;
      помилка_парсера.повідомлення = ю8"Неочікуваний токен";
      вернути помилка_парсера;
    }

    дія спробувати_розібрати_фрагмент(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера> {
      змінна ціль п = позиція_початку;
      якщо розібрана_лексика.лексеми[п].вид != герман::лексер::ВидЛексемиКлючовеСловоФрагмент {
        стрибнути помилка;
      }
      ціль асд_значення_фрагмента = виділити<АСДЗначення>();
      асд_значення_фрагмента.вид = ВидАСДЗначенняФрагмент;
      ціль фрагмент = Фрагмент { ідентифікатор = пусто, значення = пусто };
      асд_значення_фрагмента.місцезнаходження = розібрана_лексика.лексеми[п].місцезнаходження;
      п += 1;
      якщо розібрана_лексика.лексеми[п].вид != герман::лексер::ВидЛексемиІдентифікатор {
        стрибнути помилка;
      }
      ціль ідентифікатор = розібрана_лексика.лексеми[п].дані::адреса як адреса<лексер::Ідентифікатор>;
      фрагмент.ідентифікатор = ідентифікатор;
      п += 1;
      якщо розібрана_лексика.лексеми[п].вид != герман::лексер::ВидЛексемиДвокрапка {
        стрибнути помилка;
      }
      п += 1;
      ціль адреса_на_асд_значення_фрагмента: адреса<АСДЗначення> = пусто;
      ціль адреса_на_закінчення_асд_значення_фрагмента: позитивне = 0;
      ціль помилка_розбору_значення_фрагмента = спробувати_розібрати_значення_фрагмента(розібрана_лексика, п, адреса_на_асд_значення_фрагмента::адреса, адреса_на_закінчення_асд_значення_фрагмента::адреса);
      якщо помилка_розбору_значення_фрагмента != пусто {
        вернути помилка_розбору_значення_фрагмента;
      }
      фрагмент.значення = адреса_на_асд_значення_фрагмента;
      п = адреса_на_закінчення_асд_значення_фрагмента;
      п += 1;
      якщо розібрана_лексика.лексеми[п].вид != герман::лексер::ВидЛексемиКрапкакома {
        стрибнути помилка;
      }
      асд_значення_фрагмента.дані = фрагмент;
      адреса_на_асд_значення::вміст = асд_значення_фрагмента;
      адреса_на_закінчення_асд_значення::вміст = п;
      вернути пусто;
      помилка:
      ціль помилка_парсера = виділити<ПомилкаПарсера>();
      помилка_парсера.місцезнаходження = розібрана_лексика.лексеми[п].місцезнаходження;
      помилка_парсера.повідомлення = ю8"Неочікуваний токен";
      вернути помилка_парсера;
    }

    дія спробувати_розібрати_значення_фрагмента(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера> {
      змінна ціль п = позиція_початку;
      ціль помилка_парсера = виділити<ПомилкаПарсера>();
      помилка_парсера.місцезнаходження = розібрана_лексика.лексеми[п].місцезнаходження;
      помилка_парсера.повідомлення = ю8"Неочікуваний токен";
      вернути помилка_парсера;
    }

    дія спробувати_розібрати_визначення(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера> {
      ціль помилка_парсера = виділити<ПомилкаПарсера>();
      помилка_парсера.місцезнаходження = розібрана_лексика.лексеми[позиція_початку].місцезнаходження;
      помилка_парсера.повідомлення = ю8"Неочікуваний токен";
      вернути помилка_парсера;
    }

    дія спробувати_розібрати_послідовність(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера> {
      ціль помилка_парсера = виділити<ПомилкаПарсера>();
      помилка_парсера.місцезнаходження = розібрана_лексика.лексеми[позиція_початку].місцезнаходження;
      помилка_парсера.повідомлення = ю8"Неочікуваний токен";
      вернути помилка_парсера;
    }

    дія спробувати_розібрати_або(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера> {
      ціль помилка_парсера = виділити<ПомилкаПарсера>();
      помилка_парсера.місцезнаходження = розібрана_лексика.лексеми[позиція_початку].місцезнаходження;
      помилка_парсера.повідомлення = ю8"Неочікуваний токен";
      вернути помилка_парсера;
    }

    дія спробувати_розібрати_один_або_більше(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера> {
      ціль помилка_парсера = виділити<ПомилкаПарсера>();
      помилка_парсера.місцезнаходження = розібрана_лексика.лексеми[позиція_початку].місцезнаходження;
      помилка_парсера.повідомлення = ю8"Неочікуваний токен";
      вернути помилка_парсера;
    }

    дія спробувати_розібрати_нуль_або_більше(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера> {
      ціль помилка_парсера = виділити<ПомилкаПарсера>();
      помилка_парсера.місцезнаходження = розібрана_лексика.лексеми[позиція_початку].місцезнаходження;
      помилка_парсера.повідомлення = ю8"Неочікуваний токен";
      вернути помилка_парсера;
    }

    дія спробувати_розібрати_нуль_або_один(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера> {
      ціль помилка_парсера = виділити<ПомилкаПарсера>();
      помилка_парсера.місцезнаходження = розібрана_лексика.лексеми[позиція_початку].місцезнаходження;
      помилка_парсера.повідомлення = ю8"Неочікуваний токен";
      вернути помилка_парсера;
    }

    дія спробувати_розібрати_буквально(розібрана_лексика: адреса<лексер::РозібранаЛексика>, позиція_початку: позитивне, адреса_на_асд_значення: адреса<адреса<АСДЗначення>>, адреса_на_закінчення_асд_значення: адреса<позитивне>): адреса<ПомилкаПарсера> {
      ціль помилка_парсера = виділити<ПомилкаПарсера>();
      помилка_парсера.місцезнаходження = розібрана_лексика.лексеми[позиція_початку].місцезнаходження;
      помилка_парсера.повідомлення = ю8"Неочікуваний токен";
      вернути помилка_парсера;
    }

    структура РезультатРозбору {
      помилка: адреса<ПомилкаПарсера>;
      кількість_елементів: позитивне;
      елементи: памʼять<адреса<АСДЗначення>>;
    }

    дія розібрати(розібрана_лексика: адреса<лексер::РозібранаЛексика>): РезультатРозбору {
      змінна ціль кількість_елементів: позитивне = 0;
      змінна ціль елементи: памʼять<адреса<АСДЗначення>> = пусто;
      змінна ціль п: позитивне = 0;
      поки п < розібрана_лексика.кількість_лексем {
        змінна ціль асд_значення: адреса<АСДЗначення> = пусто;
        змінна ціль закінчення_асд_значення: позитивне = 0;
        ціль помилка_спроби_розбору_лексики = спробувати_розібрати_лексику(розібрана_лексика, п, асд_значення::адреса, закінчення_асд_значення::адреса);
        якщо помилка_спроби_розбору_лексики != пусто {
          ціль помилка_розбору_граматики = спробувати_розібрати_граматику(розібрана_лексика, п, асд_значення::адреса, закінчення_асд_значення::адреса);
          якщо помилка_розбору_граматики != пусто {
            вернути РезультатРозбору { помилка = помилка_спроби_розбору_лексики, ... };
          }
        }
        кількість_елементів += 1;
        елементи = перевиділити<адреса<АСДЗначення>>(елементи, кількість_елементів);
        елементи[кількість_елементів - 1] = асд_значення;
        п = закінчення_асд_значення + 1;
      }
      вернути РезультатРозбору { помилка = пусто, кількість_елементів = кількість_елементів, елементи = елементи };
    }
  }
}

дія надрукувати_розібрану_лексику(розібрана_лексика: адреса<герман::лексер::РозібранаЛексика>) {
  змінна ціль п: позитивне = 0;
  поки п < розібрана_лексика.кількість_лексем {
    ціль лексема = розібрана_лексика.лексеми[п];
    якщо лексема.вид == герман::лексер::ВидЛексемиКлючовеСловоЛексика {
      надрукувати_Ю8(ю8"КлючовеСловоЛексика");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиКлючовеСловоГраматика {
      надрукувати_Ю8(ю8"КлючовеСловоГраматика");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиКлючовеСловоФрагмент {
      надрукувати_Ю8(ю8"КлючовеСловоФрагмент");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиВідкритаДужка {
      надрукувати_Ю8(ю8"ВідкритаДужка");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиЗакритаДужка {
      надрукувати_Ю8(ю8"ЗакритаДужка");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиЗірочка {
      надрукувати_Ю8(ю8"Зірочка");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиПлюс {
      надрукувати_Ю8(ю8"Плюс");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиДвокрапка {
      надрукувати_Ю8(ю8"Двокрапка");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиКрапкакома {
      надрукувати_Ю8(ю8"Крапкакома");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиРівно {
      надрукувати_Ю8(ю8"Рівно");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиЗнакПитання {
      надрукувати_Ю8(ю8"ЗнакПитання");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиВідкритаФігурнаДужка {
      надрукувати_Ю8(ю8"ВідкритаФігурнаДужка");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиПряма {
      надрукувати_Ю8(ю8"Пряма");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиЗакритаФігурнаДужка {
      надрукувати_Ю8(ю8"ЗакритаФігурнаДужка");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиІдентифікатор {
      надрукувати_Ю8(ю8"Ідентифікатор");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиБукви {
      надрукувати_Ю8(ю8"Букви");
    }
    п += 1;
  }
}

дія надрукувати_асд_значення(асд_значення: адреса<герман::парсер::АСДЗначення>) {
  якщо асд_значення.вид == герман::парсер::ВидАСДЗначенняЛексика {
    надрукувати_Ю8(ю8"Лексика");
  } інакше якщо асд_значення.вид == герман::парсер::ВидАСДЗначенняГраматика {
    надрукувати_Ю8(ю8"Граматика");
  } інакше якщо асд_значення.вид == герман::парсер::ВидАСДЗначенняФрагмент {
    надрукувати_Ю8(ю8"Фрагмент");
  } інакше якщо асд_значення.вид == герман::парсер::ВидАСДЗначенняВизначення {
    надрукувати_Ю8(ю8"Визначення");
  } інакше якщо асд_значення.вид == герман::парсер::ВидАСДЗначенняПослідовність {
    надрукувати_Ю8(ю8"Послідовність");
  } інакше якщо асд_значення.вид == герман::парсер::ВидАСДЗначенняАбо {
    надрукувати_Ю8(ю8"Або");
  } інакше якщо асд_значення.вид == герман::парсер::ВидАСДЗначенняОдинАбоБільше {
    надрукувати_Ю8(ю8"ОдинАбоБільше");
  } інакше якщо асд_значення.вид == герман::парсер::ВидАСДЗначенняНульАбоБільше {
    надрукувати_Ю8(ю8"НульАбоБільше");
  } інакше якщо асд_значення.вид == герман::парсер::ВидАСДЗначенняНульАбоОдин {
    надрукувати_Ю8(ю8"НульАбоОдин");
  } інакше якщо асд_значення.вид == герман::парсер::ВидАСДЗначенняБуквально {
    надрукувати_Ю8(ю8"Буквально");
  } інакше {
    вивести_Ю8(ю8"НЕВІДОМЕ АСД ЗНАЧЕННЯ: ");
    println_long(long(асд_значення.вид));
  }
}

дія старт(): ц32 {
  ціль розібрана_лексика: адреса<герман::лексер::РозібранаЛексика> = пусто;
  ціль код_Ю8: памʼять<п8> = пусто;
  ціль розмір_коду_Ю8 = read_file(ю8"герман.г" як адреса<char>, код_Ю8::адреса як адреса<адреса<char>>);
  якщо код_Ю8 == пусто {
    надрукувати_Ю8(ю8"Помилка читання файлу");
    вернути 1;
  }
  ціль код_Ю32: памʼять<п32> = пусто;
  ціль розмір_коду_Ю32 = перекодувати_Ю8_в_Ю32(код_Ю8, розмір_коду_Ю8, код_Ю32::адреса);
  якщо код_Ю32 == пусто {
    // ...
    вернути 1;
  }
  ціль помилка_лексера = герман::лексер::розібрати(код_Ю32, розібрана_лексика::адреса);
  якщо помилка_лексера != пусто {
    вивести_Ю8(ю8"герман.г:");
    print_long(long(помилка_лексера.рядок));
    вивести_Ю8(ю8":");
    print_long(long(помилка_лексера.стовпець));
    вивести_Ю8(ю8" помилка: ");
    надрукувати_Ю8(помилка_лексера.повідомлення);
    вернути 1;
  }
  надрукувати_розібрану_лексику(розібрана_лексика);
  надрукувати_Ю8(ю8"---");
  ціль результат_розбору = герман::парсер::розібрати(розібрана_лексика);
  якщо результат_розбору.помилка != пусто {
    вивести_Ю8(ю8"герман.г:");
    print_long(long(результат_розбору.помилка.місцезнаходження.рядок_початку));
    вивести_Ю8(ю8":");
    print_long(long(результат_розбору.помилка.місцезнаходження.стовпець_початку));
    вивести_Ю8(ю8" ");
    вивести_Ю8(ю8"помилка");
    вивести_Ю8(ю8": ");
    надрукувати_Ю8(результат_розбору.помилка.повідомлення);
    вернути 1;
  }
  змінна ціль п: позитивне = 0;
  поки п < результат_розбору.кількість_елементів {
    надрукувати_асд_значення(результат_розбору.елементи[п]);
    п += 1;
  }
  вернути 0;
}