зовнішня дія malloc(розмір: size_t): адреса;
зовнішня дія realloc(памʼять: адреса, розмір: size_t): адреса;
зовнішня дія free(памʼять: адреса);

дія виділити<Т>(): адреса<Т>;
дія виділити<Т>(кількість: позитивне): памʼять<Т>;
дія перевиділити<Т>(значення: памʼять<Т>, кількість: позитивне): памʼять<Т>;
дія звільнити(значення: адреса);

дія виділити<Т>(): адреса<Т> {
  вернути malloc(size_t(Т.розмір)) як адреса<Т>;
}

дія виділити<Т>(кількість: позитивне): памʼять<Т> {
  вернути malloc(size_t(кількість) * Т.розмір) як памʼять<Т>;
}

дія перевиділити<Т>(значення: памʼять<Т>, кількість: позитивне): памʼять<Т> {
  вернути realloc(значення як адреса, size_t(кількість) * Т.розмір) як памʼять<Т>;
}

дія звільнити(значення: адреса) {
  free(значення);
}

дія порахувати_розмір_Ю8(значення: памʼять<п8>): позитивне {
  змінна ціль довжина: позитивне = 0;
  поки значення[довжина] != 0 {
    довжина += 1;
  }
  вернути довжина;
}

дія порахувати_розмір_Ю32(значення: памʼять<п32>): позитивне {
  змінна ціль довжина: позитивне = 0;
  поки значення[довжина] != 0 {
    довжина += 1;
  }
  вернути довжина;
}

дія дізнатись_розмір_символа_юнікоду(перший_байт: п8): п8 {
  якщо (перший_байт & 128) == 0 {
    вернути 1;
  }
  якщо (перший_байт & 224) == 192 {
    вернути 2;
  }
  якщо (перший_байт & 240) == 224 {
    вернути 3;
  }
  якщо (перший_байт & 248) == 240 {
    вернути 4;
  }
  вернути 0;
}

дія перекодувати_Ю8_в_Ю32(вхід: памʼять<п8>, розмір_входу: позитивне, адреса_виходу: адреса<памʼять<п32>>): позитивне {
  змінна ціль вихід: памʼять<п32> = виділити<п32>(розмір_входу + 1);
  змінна ціль розмір_виходу: позитивне = 0;
  змінна ціль х: позитивне = 0;
  поки х < розмір_входу {
    ціль перший_байт = вхід[х];
    ціль розмір_символа = дізнатись_розмір_символа_юнікоду(перший_байт);
    якщо розмір_символа == 1 {
      вихід[розмір_виходу] = п32(перший_байт & 127);
      розмір_виходу = розмір_виходу + 1;
    }
    якщо розмір_символа == 2 {
      ціль другий_байт = вхід[х + 1];
      вихід[розмір_виходу] = (п32(перший_байт & 31) << 6) | п32(другий_байт & 63);
      розмір_виходу = розмір_виходу + 1;
      х = х + 1;
    }
    якщо розмір_символа == 3 {
      ціль другий_байт = вхід[х + 1];
      ціль третій_байт = вхід[х + 2];
      вихід[розмір_виходу] = (п32(перший_байт & 15) << 12) | (п32(другий_байт & 63) << 6) | п32(третій_байт & 63);
      розмір_виходу = розмір_виходу + 1;
      х = х + 2;
    }
    якщо розмір_символа == 4 {
      ціль другий_байт = вхід[х + 1];
      ціль третій_байт = вхід[х + 2];
      ціль четвертий_байт = вхід[х + 3];
      вихід[розмір_виходу] = (п32(перший_байт & 15) << 18) | (п32(другий_байт & 63) << 12) | (п32(третій_байт & 63) << 6) | п32(четвертий_байт & 63);
      розмір_виходу = розмір_виходу + 1;
      х = х + 3;
    }
    х = х + 1;
  }
  вихід[розмір_виходу] = 0;
  вихід = перевиділити<п32>(вихід, розмір_виходу + 1);
  адреса_виходу::вміст = вихід;
  вернути розмір_виходу;
}

секція UNICODE {
  синонім NEWLINE = 10;
  синонім CARRIAGE_RETURN = 13;
  синонім SPACE = 32;
  синонім OPEN_PARENTHESIS = 40;
  синонім CLOSE_PARENTHESIS = 41;
  синонім ASTERISK = 42;
  синонім PLUS = 43;
  синонім COLON = 58;
  синонім SEMICOLON = 59;
  синонім QUESTION_MARK = 63;
  синонім OPEN_CURLY_BRACKET = 123;
  синонім LINE = 124;
  синонім CLOSE_CURLY_BRACKET = 125;
}

секція Г {
  секція лексер {
    структура Місцезнаходження {
      рядок_початку: позитивне;
      стовпець_початку: позитивне;
      рядок_кінця: позитивне;
      стовпець_кінця: позитивне;
    }

    структура КлючовеСловоЛексика { місцезнаходження: адреса<Місцезнаходження> }
    структура КлючовеСловоГраматика { місцезнаходження: адреса<Місцезнаходження> }
    структура КлючовеСловоФаргмент { місцезнаходження: адреса<Місцезнаходження> }
    структура ВідкритаДужка { місцезнаходження: адреса<Місцезнаходження> }
    структура ЗакритаДужка { місцезнаходження: адреса<Місцезнаходження> }
    структура Зірочка { місцезнаходження: адреса<Місцезнаходження> }
    структура Плюс { місцезнаходження: адреса<Місцезнаходження> }
    структура Двокрапка { місцезнаходження: адреса<Місцезнаходження> }
    структура Крапкакома { місцезнаходження: адреса<Місцезнаходження> }
    структура ЗнакПитання { місцезнаходження: адреса<Місцезнаходження> }
    структура ВідкритаФігурнаДужка { місцезнаходження: адреса<Місцезнаходження> }
    структура Пряма { місцезнаходження: адреса<Місцезнаходження> }
    структура ЗакритаФігурнаДужка { місцезнаходження: адреса<Місцезнаходження> }
    структура Ідентифікатор { значення: памʼять<п32>; місцезнаходження: адреса<Місцезнаходження> }
    структура Текст { значення: памʼять<п32>; місцезнаходження: адреса<Місцезнаходження> }

    синонім ВидЛексемиКлючовеСловоЛексика = 1;
    синонім ВидЛексемиКлючовеСловоГраматика = 2;
    синонім ВидЛексемиКлючовеСловоФаргмент = 3;
    синонім ВидЛексемиВідкритаДужка = 4;
    синонім ВидЛексемиЗакритаДужка = 5;
    синонім ВидЛексемиЗірочка = 6;
    синонім ВидЛексемиПлюс = 7;
    синонім ВидЛексемиДвокрапка = 8;
    синонім ВидЛексемиКрапкакома = 9;
    синонім ВидЛексемиЗнакПитання = 10;
    синонім ВидЛексемиВідкритаФігурнаДужка = 11;
    синонім ВидЛексемиПряма = 12;
    синонім ВидЛексемиЗакритаФігурнаДужка = 13;
    синонім ВидЛексемиІдентифікатор = 14;
    синонім ВидЛексемиТекст = 15;

    структура Лексема {
      вид: позитивне;
      дані: КлючовеСловоЛексика | КлючовеСловоГраматика | КлючовеСловоФаргмент | КлючовеСловоФаргмент | ВідкритаДужка | ЗакритаДужка | Зірочка | Плюс | Двокрапка | Крапкакома | ЗнакПитання | ВідкритаФігурнаДужка | Пряма | ЗакритаФігурнаДужка | Ідентифікатор | Текст;
    }

    дія виділити_лексему(дані: Лексема): адреса<Лексема> {
      ціль лексема = виділити<Лексема>();
      лексема.вид = дані.вид;
      лексема.дані = дані.дані як Текст;
      вернути лексема;
    }

    структура РозібранаЛексика {
      кількість_лексем: позитивне;
      лексеми: памʼять<адреса<Лексема>>;
    }

    дія перевірити_ключове_слово(значення: памʼять<п32>, позиція_початку: позитивне, шукане_значення: памʼять<п8>): логічне {
      змінна ціль розмір_шуканого_значення = порахувати_розмір_Ю8(шукане_значення);
      ціль шукане_значення_Ю32 = виділити<п32>(розмір_шуканого_значення + 1);
      розмір_шуканого_значення = перекодувати_Ю8_в_Ю32(шукане_значення, розмір_шуканого_значення, шукане_значення_Ю32::адреса);
      шукане_значення_Ю32[розмір_шуканого_значення] = 0;
      змінна ціль п: позитивне = 0;
      поки шукане_значення[п] != 0 {
        якщо значення[позиція_початку + п] != шукане_значення_Ю32[п] {
          звільнити(шукане_значення_Ю32 як адреса);
          вернути ні;
        }
        п += 1;
      }
      звільнити(шукане_значення_Ю32 як адреса);
      вернути так;
    }

    дія перевірити_початок_ідентифікатора(значення: памʼять<п32>, позиція_початку: позитивне): логічне {
      ціль символ = значення[позиція_початку];
      // ...
      вернути ні;
    }

    дія перевірити_ідентифікатор(значення: памʼять<п32>, позиція_початку: позитивне): позитивне {
      якщо перевірити_початок_ідентифікатора(значення, позиція_початку) == ні {
        вернути 0;
      }
      змінна ціль п: позитивне = 0;
      поки значення[п] != 0 {
        якщо значення[позиція_початку + п] == UNICODE::SPACE {
          вернути позиція_початку + п;
        }
        // ...
        п += 1;
      }
      вернути 0;
    }

    дія перевірити_початок_тексту(значення: памʼять<п32>, позиція_початку: позитивне): логічне {
      ціль символ = значення[позиція_початку];
      // ...
      вернути ні;
    }

    дія перевірити_текст(значення: памʼять<п32>, позиція_початку: позитивне): позитивне {
      якщо перевірити_початок_тексту(значення, позиція_початку) == ні {
        вернути 0;
      }
      змінна ціль п: позитивне = 0;
      поки значення[п] != 0 {
        // ...
        п += 1;
      }
      вернути 0;
    }

    дія розібрати(значення: памʼять<п32>, вихід: адреса<адреса<РозібранаЛексика>>): позитивне {
      ціль розібрана_лексика = виділити<РозібранаЛексика>();
      змінна ціль п: позитивне = 0;
      далі:
      ціль символ = значення[п];
      якщо символ == 0 {
        стрибнути стоп;
      }
      якщо символ == UNICODE::NEWLINE {
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::CARRIAGE_RETURN {
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::SPACE {
        п += 1;
        стрибнути далі;
      }
      ціль позиція_кінця_ідентифікатора = перевірити_ідентифікатор(значення, п);
      якщо позиція_кінця_ідентифікатора > 0 {
        ціль значення_ідентифікатора = виділити<п32>(позиція_кінця_ідентифікатора - п + 1);
        змінна ціль пі: позитивне = 0;
        поки пі < позиція_кінця_ідентифікатора {
          значення_ідентифікатора[пі] = значення[п + пі];
          пі += 1;
        }
        значення_ідентифікатора[позиція_кінця_ідентифікатора] = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиІдентифікатор, Ідентифікатор { значення_ідентифікатора, пусто } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += позиція_кінця_ідентифікатора;
        стрибнути далі;
      }
      ціль позиція_кінця_тексту = перевірити_текст(значення, п);
      якщо позиція_кінця_тексту > 0 {
        ціль значення_тексту = виділити<п32>(позиція_кінця_тексту - п + 1);
        змінна ціль пі: позитивне = 0;
        поки пі < позиція_кінця_тексту {
          значення_тексту[пі] = значення[п + пі];
          пі += 1;
        }
        значення_тексту[позиція_кінця_тексту] = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиТекст, Текст { значення_тексту, пусто } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += позиція_кінця_тексту;
        стрибнути далі;
      }
      якщо перевірити_ключове_слово(значення, п, ю8"лексика") {
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиКлючовеСловоЛексика, КлючовеСловоЛексика { пусто } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 6;
        стрибнути далі;
      }
      якщо перевірити_ключове_слово(значення, п, ю8"граматика") {
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиКлючовеСловоГраматика, КлючовеСловоГраматика { пусто } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 6;
        стрибнути далі;
      }
      якщо перевірити_ключове_слово(значення, п, ю8"фрагмент") {
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиКлючовеСловоФаргмент, КлючовеСловоФаргмент { пусто } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 6;
        стрибнути далі;
      }
      якщо символ == UNICODE::OPEN_PARENTHESIS {
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиВідкритаДужка, ВідкритаДужка { пусто } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
      }
      якщо символ == UNICODE::CLOSE_PARENTHESIS {
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиЗакритаДужка, ЗакритаДужка { пусто } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
      }
      якщо символ == UNICODE::ASTERISK {
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиЗірочка, Зірочка { пусто } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
      }
      якщо символ == UNICODE::PLUS {
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиПлюс, Плюс { пусто } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
      }
      якщо символ == UNICODE::COLON {
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиДвокрапка, Двокрапка { пусто } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
      }
      якщо символ == UNICODE::SEMICOLON {
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиКрапкакома, Крапкакома { пусто } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
      }
      якщо символ == UNICODE::QUESTION_MARK {
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиЗнакПитання, ЗнакПитання { пусто } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
      }
      якщо символ == UNICODE::OPEN_CURLY_BRACKET {
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиВідкритаФігурнаДужка, ВідкритаФігурнаДужка { пусто } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
      }
      якщо символ == UNICODE::LINE {
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиПряма, Пряма { пусто } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
      }
      якщо символ == UNICODE::CLOSE_CURLY_BRACKET {
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиЗакритаФігурнаДужка, ЗакритаФігурнаДужка { пусто } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
      }
      вернути 0;
      стоп:
      вихід::вміст = розібрана_лексика;
      вернути 1;
    }
  }
}