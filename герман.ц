зовнішня дія malloc(розмір: size_t): адреса;
зовнішня дія realloc(памʼять: адреса, розмір: size_t): адреса;
зовнішня дія free(памʼять: адреса);
зовнішня дія putchar(символ: char): int;
зовнішня дія printf(формат: адреса): int;

дія виділити<Т>(): адреса<Т>;
дія виділити<Т>(кількість: позитивне): памʼять<Т>;
дія перевиділити<Т>(значення: памʼять<Т>, кількість: позитивне): памʼять<Т>;
дія звільнити(значення: адреса);

дія виділити<Т>(): адреса<Т> {
  вернути malloc(size_t(Т.розмір)) як адреса<Т>;
}

дія виділити<Т>(кількість: позитивне): памʼять<Т> {
  вернути malloc(size_t(кількість) * Т.розмір) як памʼять<Т>;
}

дія перевиділити<Т>(значення: памʼять<Т>, кількість: позитивне): памʼять<Т> {
  вернути realloc(значення як адреса, size_t(кількість) * Т.розмір) як памʼять<Т>;
}

дія звільнити(значення: адреса) {
  free(значення);
}

дія вивести_Ю8(значення: памʼять<п8>) {
  printf(значення як адреса);
}

дія надрукувати_Ю8(значення: памʼять<п8>) {
  вивести_Ю8(значення);
  вивести_Ю8(ю8"\n");
}

зовнішня дія print_long(value: long);
зовнішня дія println_long(value: long);
зовнішня дія read_file(path: адреса<char>, out_address: адреса<адреса<char>>): size_t;

дія ЯТУТ() {
  надрукувати_Ю8(ю8"ЯТУТ\n");
}

дія порахувати_розмір_Ю8(значення: памʼять<п8>): позитивне {
  змінна ціль довжина: позитивне = 0;
  поки значення[довжина] != 0 {
    довжина += 1;
  }
  вернути довжина;
}

дія порахувати_розмір_Ю32(значення: памʼять<п32>): позитивне {
  змінна ціль довжина: позитивне = 0;
  поки значення[довжина] != 0 {
    довжина += 1;
  }
  вернути довжина;
}

дія дізнатись_розмір_символа_юнікоду(перший_байт: п8): п8 {
  якщо (перший_байт & 128) == 0 {
    вернути 1;
  }
  якщо (перший_байт & 224) == 192 {
    вернути 2;
  }
  якщо (перший_байт & 240) == 224 {
    вернути 3;
  }
  якщо (перший_байт & 248) == 240 {
    вернути 4;
  }
  вернути 0;
}

дія перекодувати_Ю8_в_Ю32(вхід: памʼять<п8>, розмір_входу: позитивне, адреса_виходу: адреса<памʼять<п32>>): позитивне {
  змінна ціль вихід: памʼять<п32> = виділити<п32>(розмір_входу + 1);
  змінна ціль розмір_виходу: позитивне = 0;
  змінна ціль х: позитивне = 0;
  поки х < розмір_входу {
    ціль перший_байт = вхід[х];
    ціль розмір_символа = дізнатись_розмір_символа_юнікоду(перший_байт);
    якщо розмір_символа == 1 {
      вихід[розмір_виходу] = п32(перший_байт & 127);
      розмір_виходу = розмір_виходу + 1;
    }
    якщо розмір_символа == 2 {
      ціль другий_байт = вхід[х + 1];
      вихід[розмір_виходу] = (п32(перший_байт & 31) << 6) | п32(другий_байт & 63);
      розмір_виходу = розмір_виходу + 1;
      х = х + 1;
    }
    якщо розмір_символа == 3 {
      ціль другий_байт = вхід[х + 1];
      ціль третій_байт = вхід[х + 2];
      вихід[розмір_виходу] = (п32(перший_байт & 15) << 12) | (п32(другий_байт & 63) << 6) | п32(третій_байт & 63);
      розмір_виходу = розмір_виходу + 1;
      х = х + 2;
    }
    якщо розмір_символа == 4 {
      ціль другий_байт = вхід[х + 1];
      ціль третій_байт = вхід[х + 2];
      ціль четвертий_байт = вхід[х + 3];
      вихід[розмір_виходу] = (п32(перший_байт & 15) << 18) | (п32(другий_байт & 63) << 12) | (п32(третій_байт & 63) << 6) | п32(четвертий_байт & 63);
      розмір_виходу = розмір_виходу + 1;
      х = х + 3;
    }
    х = х + 1;
  }
  вихід[розмір_виходу] = 0;
  вихід = перевиділити<п32>(вихід, розмір_виходу + 1);
  адреса_виходу::вміст = вихід;
  вернути розмір_виходу;
}

секція UNICODE {
  синонім NEWLINE = 10;
  синонім CARRIAGE_RETURN = 13;
  синонім SPACE = 32;
  синонім APOSTROPHE = 39;
  синонім OPEN_PARENTHESIS = 40;
  синонім CLOSE_PARENTHESIS = 41;
  синонім ASTERISK = 42;
  синонім PLUS = 43;
  синонім COLON = 58;
  синонім SEMICOLON = 59;
  синонім QUESTION_MARK = 63;
  синонім OPEN_CURLY_BRACKET = 123;
  синонім LINE = 124;
  синонім CLOSE_CURLY_BRACKET = 125;
}

секція герман {
  секція лексер {
    структура Місцезнаходження {
      рядок_початку: позитивне;
      стовпець_початку: позитивне;
      рядок_кінця: позитивне;
      стовпець_кінця: позитивне;
    }

    структура КлючовеСловоЛексика { місцезнаходження: адреса<Місцезнаходження> }
    структура КлючовеСловоГраматика { місцезнаходження: адреса<Місцезнаходження> }
    структура КлючовеСловоФаргмент { місцезнаходження: адреса<Місцезнаходження> }
    структура ВідкритаДужка { місцезнаходження: адреса<Місцезнаходження> }
    структура ЗакритаДужка { місцезнаходження: адреса<Місцезнаходження> }
    структура Зірочка { місцезнаходження: адреса<Місцезнаходження> }
    структура Плюс { місцезнаходження: адреса<Місцезнаходження> }
    структура Двокрапка { місцезнаходження: адреса<Місцезнаходження> }
    структура Крапкакома { місцезнаходження: адреса<Місцезнаходження> }
    структура ЗнакПитання { місцезнаходження: адреса<Місцезнаходження> }
    структура ВідкритаФігурнаДужка { місцезнаходження: адреса<Місцезнаходження> }
    структура Пряма { місцезнаходження: адреса<Місцезнаходження> }
    структура ЗакритаФігурнаДужка { місцезнаходження: адреса<Місцезнаходження> }
    структура Ідентифікатор { значення: памʼять<п32>; місцезнаходження: адреса<Місцезнаходження> }
    структура Текст { значення: памʼять<п32>; місцезнаходження: адреса<Місцезнаходження> }

    синонім ВидЛексемиКлючовеСловоЛексика = 1;
    синонім ВидЛексемиКлючовеСловоГраматика = 2;
    синонім ВидЛексемиКлючовеСловоФаргмент = 3;
    синонім ВидЛексемиВідкритаДужка = 4;
    синонім ВидЛексемиЗакритаДужка = 5;
    синонім ВидЛексемиЗірочка = 6;
    синонім ВидЛексемиПлюс = 7;
    синонім ВидЛексемиДвокрапка = 8;
    синонім ВидЛексемиКрапкакома = 9;
    синонім ВидЛексемиЗнакПитання = 10;
    синонім ВидЛексемиВідкритаФігурнаДужка = 11;
    синонім ВидЛексемиПряма = 12;
    синонім ВидЛексемиЗакритаФігурнаДужка = 13;
    синонім ВидЛексемиІдентифікатор = 14;
    синонім ВидЛексемиТекст = 15;

    структура Лексема {
      вид: позитивне;
      дані: КлючовеСловоЛексика | КлючовеСловоГраматика | КлючовеСловоФаргмент | КлючовеСловоФаргмент | ВідкритаДужка | ЗакритаДужка | Зірочка | Плюс | Двокрапка | Крапкакома | ЗнакПитання | ВідкритаФігурнаДужка | Пряма | ЗакритаФігурнаДужка | Ідентифікатор | Текст;
    }

    дія виділити_лексему(дані: Лексема): адреса<Лексема> {
      ціль лексема = виділити<Лексема>();
      лексема.вид = дані.вид;
      лексема.дані = дані.дані як Текст;
      вернути лексема;
    }

    структура РозібранаЛексика {
      кількість_лексем: позитивне;
      лексеми: памʼять<адреса<Лексема>>;
    }

    дія перевірити_початок_ідентифікатора(значення: памʼять<п32>, позиція_початку: позитивне): логічне {
      ціль символ = значення[позиція_початку];
      якщо символ == UNICODE::NEWLINE {
        вернути ні;
      }
      якщо символ == UNICODE::CARRIAGE_RETURN {
        вернути ні;
      }
      якщо символ == UNICODE::SPACE {
        вернути ні;
      }
      якщо символ == UNICODE::APOSTROPHE {
        вернути ні;
      }
      якщо символ == UNICODE::OPEN_PARENTHESIS {
        вернути ні;
      }
      якщо символ == UNICODE::CLOSE_PARENTHESIS {
        вернути ні;
      }
      якщо символ == UNICODE::ASTERISK {
        вернути ні;
      }
      якщо символ == UNICODE::PLUS {
        вернути ні;
      }
      якщо символ == UNICODE::COLON {
        вернути ні;
      }
      якщо символ == UNICODE::SEMICOLON {
        вернути ні;
      }
      якщо символ == UNICODE::QUESTION_MARK {
        вернути ні;
      }
      якщо символ == UNICODE::OPEN_CURLY_BRACKET {
        вернути ні;
      }
      якщо символ == UNICODE::LINE {
        вернути ні;
      }
      якщо символ == UNICODE::CLOSE_CURLY_BRACKET {
        вернути ні;
      }
      вернути так;
    }

    дія перевірити_продовження_ідентифікатора(значення: памʼять<п32>, позиція_початку: позитивне): логічне {
      вернути перевірити_початок_ідентифікатора(значення, позиція_початку);
    }

    дія перевірити_ідентифікатор(значення: памʼять<п32>, позиція_початку: позитивне): позитивне {
      якщо перевірити_початок_ідентифікатора(значення, позиція_початку) == ні {
        вернути 0;
      }
      змінна ціль п: позитивне = 1;
      поки значення[позиція_початку + п] != 0 {
        якщо перевірити_продовження_ідентифікатора(значення, позиція_початку + п) == ні {
          вернути п;
        }
        п += 1;
      }
      вернути 0;
    }

    дія перевірити_початок_тексту(значення: памʼять<п32>, позиція_початку: позитивне): логічне {
      ціль символ = значення[позиція_початку];
      якщо символ == UNICODE::APOSTROPHE {
        вернути так;
      }
      вернути ні;
    }

    дія перевірити_продовження_тексту(значення: памʼять<п32>, позиція_початку: позитивне): логічне {
      ціль символ = значення[позиція_початку];
      якщо символ == UNICODE::APOSTROPHE {
        вернути ні;
      }
      вернути так;
    }

    дія перевірити_закінчення_тексту(значення: памʼять<п32>, позиція_початку: позитивне): логічне {
      ціль символ = значення[позиція_початку];
      якщо символ == UNICODE::APOSTROPHE {
        вернути так;
      }
      вернути ні;
    }

    дія перевірити_текст(значення: памʼять<п32>, позиція_початку: позитивне): позитивне {
      якщо перевірити_початок_тексту(значення, позиція_початку) == ні {
        вернути 0;
      }
      змінна ціль п: позитивне = 1;
      поки значення[позиція_початку + п] != 0 {
        якщо значення[позиція_початку + п] == 92 {
          п += 1;
        } інакше якщо перевірити_продовження_тексту(значення, позиція_початку + п) {
        } інакше якщо перевірити_закінчення_тексту(значення, позиція_початку + п) {
          вернути п;
        } інакше {
          вернути 0;
        }
        п += 1;
      }
      вернути 0;
    }

    дія перевірити_ключове_слово(значення: памʼять<п32>, позиція_початку: позитивне, шукане_значення: памʼять<п8>): логічне {
      ціль шукане_значення_Ю32: памʼять<п32> = пусто;
      ціль розмір_шуканого_значення_Ю32 = перекодувати_Ю8_в_Ю32(шукане_значення, порахувати_розмір_Ю8(шукане_значення), шукане_значення_Ю32::адреса);
      змінна ціль п: позитивне = 0;
      поки шукане_значення_Ю32[п] != 0 {
        якщо значення[позиція_початку + п] == 0 {
          звільнити(шукане_значення_Ю32 як адреса);
          вернути ні;
        }
        якщо значення[позиція_початку + п] != шукане_значення_Ю32[п] {
          звільнити(шукане_значення_Ю32 як адреса);
          вернути ні;
        }
        п += 1;
      }
      звільнити(шукане_значення_Ю32 як адреса);
      вернути так;
    }

    структура ПомилкаЛексера {
      рядок: позитивне;
      стовпець: позитивне;
      повідомлення: памʼять<п8>;
    }

    дія розібрати(значення: памʼять<п32>, вихід: адреса<адреса<РозібранаЛексика>>): адреса<ПомилкаЛексера> {
      ціль розібрана_лексика = виділити<РозібранаЛексика>();
      розібрана_лексика.кількість_лексем = 0;
      розібрана_лексика.лексеми = пусто;
      змінна ціль рядок: позитивне = 1;
      змінна ціль стовпець: позитивне = 1;
      змінна ціль п_початку_рядка: позитивне = 0;
      змінна ціль п: позитивне = 0;
      далі:
      стовпець = п - п_початку_рядка + 1;
      ціль символ = значення[п];
      якщо символ == 0 {
        стрибнути стоп;
      }
      якщо перевірити_ключове_слово(значення, п, ю8"лексика") {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиКлючовеСловоЛексика, КлючовеСловоЛексика { місцезнаходження } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 7;
        стрибнути далі;
      }
      якщо перевірити_ключове_слово(значення, п, ю8"граматика") {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиКлючовеСловоГраматика, КлючовеСловоГраматика { місцезнаходження } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 9;
        стрибнути далі;
      }
      якщо перевірити_ключове_слово(значення, п, ю8"фрагмент") {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиКлючовеСловоФаргмент, КлючовеСловоФаргмент { місцезнаходження } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 8;
        стрибнути далі;
      }
      якщо символ == UNICODE::OPEN_PARENTHESIS {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиВідкритаДужка, ВідкритаДужка { місцезнаходження } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::CLOSE_PARENTHESIS {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиЗакритаДужка, ЗакритаДужка { місцезнаходження } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::ASTERISK {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиЗірочка, Зірочка { місцезнаходження } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::PLUS {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиПлюс, Плюс { місцезнаходження } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::COLON {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиДвокрапка, Двокрапка { місцезнаходження } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::SEMICOLON {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиКрапкакома, Крапкакома { місцезнаходження } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::QUESTION_MARK {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиЗнакПитання, ЗнакПитання { місцезнаходження } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::OPEN_CURLY_BRACKET {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиВідкритаФігурнаДужка, ВідкритаФігурнаДужка { місцезнаходження } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::LINE {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиПряма, Пряма { місцезнаходження } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::CLOSE_CURLY_BRACKET {
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиЗакритаФігурнаДужка, ЗакритаФігурнаДужка { місцезнаходження } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
        стрибнути далі;
      }
      ціль довжина_ідентифікатора = перевірити_ідентифікатор(значення, п);
      якщо довжина_ідентифікатора > 0 {
        ціль значення_ідентифікатора = виділити<п32>(довжина_ідентифікатора + 1);
        змінна ціль пі: позитивне = 0;
        поки пі < довжина_ідентифікатора {
          значення_ідентифікатора[пі] = значення[п + пі];
          пі += 1;
        }
        значення_ідентифікатора[довжина_ідентифікатора] = 0;
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиІдентифікатор, Ідентифікатор { значення_ідентифікатора, місцезнаходження } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += довжина_ідентифікатора;
        стрибнути далі;
      }
      ціль довжина_тексту = перевірити_текст(значення, п);
      якщо довжина_тексту > 0 {
        ціль значення_тексту = виділити<п32>(довжина_тексту + 1);
        змінна ціль пі: позитивне = 0;
        поки пі < довжина_тексту {
          значення_тексту[пі] = значення[п + пі];
          пі += 1;
        }
        значення_тексту[довжина_тексту] = 0;
        ціль місцезнаходження = виділити<Місцезнаходження>();
        місцезнаходження.рядок_початку = рядок;
        місцезнаходження.стовпець_початку = стовпець;
        місцезнаходження.рядок_кінця = 0;
        місцезнаходження.стовпець_кінця = 0;
        ціль лексема = виділити_лексему(Лексема { ВидЛексемиТекст, Текст { значення_тексту, місцезнаходження } });
        розібрана_лексика.лексеми = перевиділити<адреса<Лексема>>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += довжина_тексту + 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::NEWLINE {
        п += 1;
        рядок += 1;
        стовпець = 1;
        п_початку_рядка = п;
        стрибнути далі;
      }
      якщо символ == UNICODE::CARRIAGE_RETURN {
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::SPACE {
        п += 1;
        стрибнути далі;
      }
      ціль помилка_лексера = виділити<ПомилкаЛексера>();
      помилка_лексера.рядок = рядок;
      помилка_лексера.стовпець = стовпець;
      помилка_лексера.повідомлення = ю8"Неочікуваний токен";
      вернути помилка_лексера;
      стоп:
      вихід::вміст = розібрана_лексика;
      вернути пусто;
    }
  }
}

дія надрукувати_розібрану_лексику(розібрана_лексика: адреса<герман::лексер::РозібранаЛексика>) {
  змінна ціль п: позитивне = 0;
  поки п < розібрана_лексика.кількість_лексем {
    ціль лексема = розібрана_лексика.лексеми[п];
    якщо лексема.вид == герман::лексер::ВидЛексемиКлючовеСловоЛексика {
      надрукувати_Ю8(ю8"КлючовеСловоЛексика");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиКлючовеСловоГраматика {
      надрукувати_Ю8(ю8"КлючовеСловоГраматика");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиКлючовеСловоФаргмент {
      надрукувати_Ю8(ю8"КлючовеСловоФаргмент");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиВідкритаДужка {
      надрукувати_Ю8(ю8"ВідкритаДужка");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиЗакритаДужка {
      надрукувати_Ю8(ю8"ЗакритаДужка");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиЗірочка {
      надрукувати_Ю8(ю8"Зірочка");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиПлюс {
      надрукувати_Ю8(ю8"Плюс");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиДвокрапка {
      надрукувати_Ю8(ю8"Двокрапка");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиКрапкакома {
      надрукувати_Ю8(ю8"Крапкакома");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиЗнакПитання {
      надрукувати_Ю8(ю8"ЗнакПитання");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиВідкритаФігурнаДужка {
      надрукувати_Ю8(ю8"ВідкритаФігурнаДужка");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиПряма {
      надрукувати_Ю8(ю8"Пряма");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиЗакритаФігурнаДужка {
      надрукувати_Ю8(ю8"ЗакритаФігурнаДужка");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиІдентифікатор {
      надрукувати_Ю8(ю8"Ідентифікатор");
    }
    якщо лексема.вид == герман::лексер::ВидЛексемиТекст {
      надрукувати_Ю8(ю8"Текст");
    }
    п += 1;
  }
}

дія старт(): ц32 {
  ціль розібрана_лексика: адреса<герман::лексер::РозібранаЛексика> = пусто;
  ціль код_Ю8: памʼять<п8> = пусто;
  ціль розмір_коду_Ю8 = read_file(ю8"мавка.г" як адреса<char>, код_Ю8::адреса як адреса<адреса<char>>);
  якщо код_Ю8 == пусто {
    надрукувати_Ю8(ю8"Помилка читання файлу");
    вернути 1;
  }
  ціль код_Ю32: памʼять<п32> = пусто;
  ціль розмір_коду_Ю32 = перекодувати_Ю8_в_Ю32(код_Ю8, розмір_коду_Ю8, код_Ю32::адреса);
  якщо код_Ю32 == пусто {
    // ...
    вернути 1;
  }
  ціль помилка_лексера = герман::лексер::розібрати(код_Ю32, розібрана_лексика::адреса);
  якщо помилка_лексера != пусто {
    вивести_Ю8(ю8"мавка.г:");
    print_long(long(помилка_лексера.рядок));
    вивести_Ю8(ю8":");
    print_long(long(помилка_лексера.стовпець));
    вивести_Ю8(ю8" помилка: ");
    надрукувати_Ю8(помилка_лексера.повідомлення);
    вернути 1;
  }
  надрукувати_розібрану_лексику(розібрана_лексика);
  вернути 0;
}